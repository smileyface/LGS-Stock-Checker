# This configuration sets up Nginx to act as a reverse proxy.
# It serves static files directly and forwards all other requests (like API calls and page loads)
# to the backend Flask application. It also properly handles WebSocket connections for Socket.IO.

server {
    listen 80;
    server_name _; # Listen on all hostnames

    # The root directory where Nginx will look for static files.
    # This should match the COPY destination in the frontend Dockerfile.
    root /usr/share/nginx/html;

    # This is the key part for integrating a static frontend with a dynamic backend.
    # For any incoming request, Nginx will first try to find a corresponding file
    # in the `root` directory ($uri). If it can't find a file, it will fall back
    # to the named location @proxy_to_app, which forwards the request to the backend.
    location / {
        try_files $uri @proxy_to_app;
    }

    # This special location block is required to correctly proxy WebSocket connections
    # for Socket.IO. It passes the necessary headers to upgrade the connection.
    location /socket.io {
        # Forward the request to the backend service on its internal port.
        # 'backend' is the service name from docker-compose.yml.
        proxy_pass http://backend:5000/socket.io;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "Upgrade";
        proxy_set_header Host $host;
    }

    # This is the named location that acts as the fallback for the `try_files` directive.
    # All non-static requests will be proxied to the Flask application.
    location @proxy_to_app {
        proxy_pass http://backend:5000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
# This configuration sets up Nginx to act as a reverse proxy.
# It serves static files directly and forwards all other requests (like API calls and page loads)
# to the backend Flask application. It also properly handles WebSocket connections for Socket.IO.

server {
    listen 80;
    server_name _; # Listen on all hostnames

    # The root directory where Nginx will look for static files.
    # This should match the COPY destination in the frontend Dockerfile.
    root /usr/share/nginx/html;

    # This is the key part for integrating a static frontend with a dynamic backend.
    # For any incoming request, Nginx will first try to find a corresponding file
    # in the `root` directory ($uri). If it can't find a file, it will fall back
    # to the named location @proxy_to_app, which forwards the request to the backend.
    location / {
        try_files $uri @proxy_to_app;
    }

    # This special location block is required to correctly proxy WebSocket connections
    # for Socket.IO. It passes the necessary headers to upgrade the connection.
    location /socket.io {
        # Forward the request to the backend service on its internal port.
        # 'backend' is the service name from docker-compose.yml.
        proxy_pass http://backend:5000/socket.io;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "Upgrade";
        proxy_set_header Host $host;
    }

    # This is the named location that acts as the fallback for the `try_files` directive.
    # All non-static requests will be proxied to the Flask application.
    location @proxy_to_app {
        proxy_pass http://backend:5000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
