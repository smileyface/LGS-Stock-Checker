import os
import pkgutil
import importlib
import sys
import typing
import inspect
from pydantic import BaseModel
# Add the project root to sys.path so we can import backend modules
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))
import backend.schema as schema  # noqa

FRONTEND_SCHEMA_DIR = "frontend/src/schema"


def get_messages():
    """Recursively finds all Pydantic models in the backend.schema package."""
    models = []
    for _, name, _ in pkgutil.walk_packages(schema.__path__, schema.__name__ + "."):
        try:
            module = importlib.import_module(name)
            for _, obj in inspect.getmembers(module):
                if (inspect.isclass(obj)
                    and issubclass(obj, BaseModel)
                        and obj is not BaseModel):
                    # Only include models defined in the module (not imported ones)
                    if obj.__module__ == name:
                        models.append(obj)
        except ImportError as e:
            print(f"Failed to import {name}: {e}")
    return models


def map_json_type_to_ts(prop: dict) -> str:
    if "$ref" in prop:
        name = prop["$ref"].split("/")[-1]
        return name.replace("[", "_").replace("]", "")

    if "anyOf" in prop:
        # Filter out nulls to handle Optional[] cleanly if needed,
        # or just map all options.
        types = [map_json_type_to_ts(p) for p in prop["anyOf"]]
        return " | ".join(sorted(set(types)))

    t = prop.get("type")

    if "const" in prop:
        return f'"{prop["const"]}"'

    if t == "string":
        if "enum" in prop:
            return " | ".join([f'"{e}"' for e in prop["enum"]])
        return "string"
    if t in ["integer", "number"]:
        return "number"
    if t == "boolean":
        return "boolean"
    if t == "array":
        items = prop.get("items", {})
        return f"{map_json_type_to_ts(items)}[]"
    if t == "object":
        if "additionalProperties" in prop:
            ap = prop["additionalProperties"]
            if isinstance(ap, bool):
                return "{ [key: string]: any }" if ap else "object"
            val_type = map_json_type_to_ts(ap)
            return f"{{ [key: string]: {val_type} }}"
        return "any"
    if t == "null":
        return "null"

    return "any"


def generate_typescript_definitions(models: typing.List[typing.Type[BaseModel]],
                                    output_dir: str):
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    output_file = os.path.join(output_dir, "server_types.ts")
    lines = [
        "// Auto-generated by utilities/align_channels.py",
        "// DO NOT EDIT THIS FILE MANUALLY",
        ""
    ]

    for model in models:
        schema = model.model_json_schema()
        name = schema.get("title", model.__name__)
        name = name.replace("[", "_").replace("]", "")

        # Handle Class Docstring
        if "description" in schema:
            lines.append("/**")
            lines.append(f" * {schema['description']}")
            lines.append(" */")

        lines.append(f"export interface {name} {{")

        props = schema.get("properties", {})
        required = set(schema.get("required", []))

        for field_name, field_schema in props.items():
            ts_type = map_json_type_to_ts(field_schema)
            is_optional = field_name not in required
            # Handle nullable fields (Optional in Python)
            if "null" in ts_type.split(" | "):
                is_optional = True
                ts_type = ts_type.replace(" | null", "").replace("null | ", "")

            lines.append(f"  {field_name}{'?' if is_optional else ''}: {ts_type};")

        lines.append("}")
        lines.append("")

    lines.append("/**")
    lines.append(" * Helper to cast a dictionary to a specific type.")
    lines.append(" */")
    lines.append("export function asType<T>(data: { [key: string]: any }): T {")
    lines.append("  return data as unknown as T;")
    lines.append("}")

    with open(output_file, "w") as f:
        f.write("\n".join(lines))

    print(f"âœ… Generated TypeScript definitions in {output_file}")


if __name__ == "__main__":
    found_models = get_messages()
    print(f"Found {len(found_models)} Pydantic models.")

    project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
    abs_output_dir = os.path.join(project_root, FRONTEND_SCHEMA_DIR)

    generate_typescript_definitions(found_models, abs_output_dir)
